{"version":3,"sources":["views/reactDemo/02tabSelector/TabSelector.jsx"],"names":["TabSelector","itemClasses","option","selected","_this","props","key","_this2","this","_this$props","options","onChange","react__WEBPACK_IMPORTED_MODULE_9___default","a","createElement","className","antd_es_row__WEBPACK_IMPORTED_MODULE_1__","type","gutter","map","antd_es_col__WEBPACK_IMPORTED_MODULE_3__","onClick","title","Component","defaultProps","TabSelectorSample","state","_this3","setState"],"mappings":"qNAoBMA,qNACJC,YAAc,SAACC,GAAW,IAChBC,EAAaC,EAAKC,MAAlBF,SAER,OADiBD,EAAOI,MAAQH,EACd,6BAA+B,6FAEzC,IAAAI,EAAAC,KAAAC,EACsBD,KAAKH,MAA3BK,EADAD,EACAC,QAASC,EADTF,EACSE,SACjB,OACEC,EAAAC,EAAAC,cAAA,OAAKC,UAAW,gBACdH,EAAAC,EAAAC,cAAA,OAAKC,UAAW,SAAhB,gBAGAH,EAAAC,EAAAC,cAAAE,EAAA,GAAKC,KAAM,OAAQC,OAAQ,GAAIH,UAAW,6BACvCL,EAAQS,IAAI,SAAAjB,GAAM,OACjBU,EAAAC,EAAAC,cAAAM,EAAA,GACEd,IAAKJ,EAAOI,IACZS,UAAWR,EAAKN,YAAYC,GAC5BmB,QAAS,kBAAMV,EAAST,EAAOI,OAE9BJ,EAAOoB,kBApBIC,cAiC1BvB,EAAYwB,aAAe,CACzBd,QAAS,GACTC,SAAU,kBAENc,6MACJC,MAAQ,CACNvB,SAAU,UAEZO,QAAU,CACR,CAAEJ,IAAK,MAAOgB,MAAO,OACrB,CAAEhB,IAAK,OAAQgB,MAAO,QACtB,CAAEhB,IAAK,SAAUgB,MAAO,aAE1BX,SAAW,SAACR,GACVwB,EAAKC,SAAS,CAAEzB,sFAER,IACAA,EAAaK,KAAKkB,MAAlBvB,SACR,OACES,EAAAC,EAAAC,cAACd,EAAD,CACEU,QAASF,KAAKE,QACdP,SAAUA,EACVQ,SAAUH,KAAKG,kBAlBSY,aAuBjBE","file":"static/js/6.b4b1ebc7.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Row, Col } from 'antd';\nimport './TabSelector.scss';\n\n/**\n * 组件设计时的几个考虑：\n *  1. 为什么要将selected通过props传入，而不是通过内部的state来进行控制\n *      如果通过state来控制的话，用户并不能修改选中项，这在用户不关心内部的选中项，只是关心点击后选中内容的时候可以使用。\n *      而如果用户要完全控制选中项的时候：比如要设置选中项，我们就需要通过`props`来将`state`进行传入\n *  2. 为什么要还传入一个onChange函数\n *      onChange函数的作用：\n *        1. 暴露一个api：让用户可以在tab切换的时候做一些事情\n *        2. 由于传入的props不能修改，我们需要将最新的值通过回调函数的参数传回来，然后通过this.setState()进行修改，\n *           之后再render的时候就会将最新的props传入\n *\n * 和`vue`相比的几个问题：\n *  1. .sync可以通过this.$emit来将改动的值自动设置，而react只能手动通过onChange将参数传回进行更改\n *  2. class的绑定并不灵活，还得自己来处理动态class的情况\n */\nclass TabSelector extends Component {\n  itemClasses = (option) => {\n    const { selected } = this.props;\n    const isSelect = option.key === selected;\n    return isSelect ? 'tab-selector-item selected' : 'tab-selector-item';\n  };\n  render () {\n    const { options, onChange } = this.props;\n    return (\n      <div className={'tab-selector'}>\n        <div className={'label'}>\n          TabSelector:\n        </div>\n        <Row type={'flex'} gutter={24} className={'tab-selector-item-wrapper'}>\n          {options.map(option => (\n            <Col\n              key={option.key}\n              className={this.itemClasses(option)}\n              onClick={() => onChange(option.key)}\n            >\n              {option.title}\n            </Col>\n          ))}\n        </Row>\n      </div>\n    );\n  }\n}\nTabSelector.propTypes = {\n  options: PropTypes.arrayOf(PropTypes.object),\n  selected: PropTypes.string.isRequired,\n  onChange: PropTypes.func\n};\nTabSelector.defaultProps = {\n  options: [],\n  onChange: () => {}\n};\nclass TabSelectorSample extends Component {\n  state = {\n    selected: 'blue'\n  };\n  options = [\n    { key: 'red', title: 'Red' },\n    { key: 'blue', title: 'Blue' },\n    { key: 'orange', title: 'Orange' }\n  ];\n  onChange = (selected) => {\n    this.setState({ selected });\n  };\n  render () {\n    const { selected } = this.state;\n    return (\n      <TabSelector\n        options={this.options}\n        selected={selected}\n        onChange={this.onChange}\n      />\n    );\n  }\n}\nexport default TabSelectorSample;\n"],"sourceRoot":""}